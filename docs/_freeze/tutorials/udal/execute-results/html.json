{
  "hash": "8b5ada0796cea820889db64bf4805c70",
  "result": {
    "markdown": "---\ntitle: National Data Platform (UDAL)\nsubtitle: \"NHS England Datastore\"\nauthor: \"Simon Wellesley-Miller\"\ndate: \"2023-02-05\"\ncategories: [SQL, R]\n---\n\n\n## Query UDAL in R\n\nFirst load in appropriate libraries; `DBI` is the main one for the connection to UDAL, and `tidyverse` allows you to to use `dbpylr` verbs.\n\n```r\nlibrary (DBI)\nlibrary (odbc)\nlibrary (tidyverse)\nlibrary (dbplyr)\nsource ('personal_credentials.R')\n```\n\n::: {.callout-warning}\n## Important!\nIt is good practice to *not* publish connection strings, therefore I have put them into a separate file as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserv  <-\"<database-server-address>\"\ndb  <- \"<database-name>\"\nuser  <- \"<udal-account-username>\"\n```\n:::\n\n:::\n\n## Open Connection\n\nThis is the main connection command:\n\n```r\ncon_udal <- dbConnect(\n  drv = odbc(),\n  driver = \"ODBC Driver 17 for SQL Server\",\n  server = serv,\n  database = db,\n  UID = user,\n  authentication = \"ActiveDirectoryInteractive\"\n)\n```\n\n::: {.callout-note}\n## Note\nWhen this is run a separate window will open where you will need to enter two part authentication \n\n::: \n\nOnce that has been run you will see a connection appear in the connections tab - top right\n\n## Running SQL Query\n\nYou can parse a standard sql query using a `dbGetQuery()` command, it requires the connection string (that you have already specified above) and the sql code.\n\n- Each query can return one dataframe of data, if you have multiple queries use separate queries (there is a way around this but it is quite complex)\n- The `dbGetQuery()` does not like temporary tables (they are bad practice anyway), but it will accept common table expressions (CTEs) or subqueries\n\n```r\ndf_one <- dbGetQuery(\n  conn = con_udal,\n  statement = \"\n\n  SELECT  appointment_date,\n          appointment_status,\n          HCP_Type,\n          Appointment_Mode,\n          Count_Of_Appointments\n\n  FROM  [UKHF_Appts_In_General_Practice].[Appts_GP_Daily1]\n\n  WHERE Appointment_Date >= '2022-11-25'\n\n  \"\n  )\n```\n\nAlternatively we can keep our sql separate and read in a script:\n\n```r\ndf_two <- dbGetQuery(con_udal, \n                     read_file(\"test_query.sql\"))\n```\n\n## Using `dbpylr`\n\nFinally we can skip sql entirely and query using dplyr like verbs. First we make a connection to the table we want - note that this does not actually create a table - more of a virtual one:\n\n```r\ndbpylr_table <- tbl(con_udal, \n                    in_schema(\"UKHF_Appts_In_General_Practice\", \n                              \"Appts_GP_Daily1\"))\n```\n\nHowever we can then use our virtual table and query it using dplyr verbs.\n\nEnsure to add collect at the end to convert the final results into an actual dataframe:\n\n```r\ndf_three <- dbpylr_table %>%\n  select (Appointment_Date,\n          Appointment_Status,\n          HCP_Type,\n          Appointment_Mode,\n          Count_Of_Appointments) %>%\n  filter (Appointment_Date >= '2022-11-25') %>%\n  collect()\n```\n\n## Close Connection \n\nWhen you have finished with the connection it is good practice to close it:\n\n```r\ndbDisconnect(con_udal)\n```\n\nta da!\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}